<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactive Clustering Visualization</title>
  
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <style>
    .viz-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .viz-title {
      color: #495057;
      font-weight: 600;
      margin-bottom: 15px;
    }
    
    .step-controls {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .step-button {
      margin: 5px;
      min-width: 120px;
    }
    
    .viz-image {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .algorithm-tabs {
      margin-bottom: 20px;
    }
    
    .parameter-controls {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .step-description {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 15px;
      margin: 15px 0;
      border-radius: 0 8px 8px 0;
    }
    
    .loading {
      display: none;
      text-align: center;
      padding: 20px;
    }
    
    .step-indicator {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }
    
    .step-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #dee2e6;
      margin: 0 5px;
      transition: all 0.3s ease;
    }
    
    .step-dot.active {
      background: #007bff;
    }
    
    .step-dot.completed {
      background: #28a745;
    }
  </style>
</head>
<body class="bg-light">
  <div class="container py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h1 class="m-0">Interactive Clustering Visualization</h1>
      <div>
        <a href="/" class="btn btn-outline-secondary me-2">Back to List</a>
        <a href="/clustering" class="btn btn-outline-info">Clustering Analysis</a>
      </div>
    </div>

    <!-- Algorithm Selection -->
    <div class="viz-container">
      <h3 class="viz-title">Algorithm Selection</h3>
      <div class="algorithm-tabs">
        <ul class="nav nav-tabs" id="algorithmTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="kmeans-tab" data-bs-toggle="tab" 
                    data-bs-target="#kmeans-panel" type="button" role="tab">
              K-means
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="dbscan-tab" data-bs-toggle="tab" 
                    data-bs-target="#dbscan-panel" type="button" role="tab">
              DBSCAN
            </button>
          </li>
        </ul>
      </div>
    </div>

    <!-- Tab Content -->
    <div class="tab-content" id="algorithmTabContent">
      <!-- K-means Panel -->
      <div class="tab-pane fade show active" id="kmeans-panel" role="tabpanel">
        <div class="viz-container">
          <h3 class="viz-title">K-means Clustering</h3>
          
          <!-- Parameter Controls -->
          <div class="parameter-controls">
            <div class="row">
              <div class="col-md-4">
                <label for="k-clusters" class="form-label">Number of clusters (k):</label>
                <input type="number" class="form-control" id="k-clusters" value="4" min="2" max="8">
              </div>
              <div class="col-md-4">
                <label for="k-samples" class="form-label">Number of points:</label>
                <input type="number" class="form-control" id="k-samples" value="100" min="50" max="500" step="50">
              </div>
              <div class="col-md-4">
                <label for="k-iteration" class="form-label">Iteration:</label>
                <input type="number" class="form-control" id="k-iteration" value="0" min="0" max="20" readonly>
              </div>
            </div>
          </div>

          <!-- Step Controls -->
          <div class="step-controls">
            <h5>Algorithm steps:</h5>
            <div class="d-flex flex-wrap">
              <button class="btn btn-primary step-button" id="kmeans-init">1. Show data</button>
              <button class="btn btn-outline-primary step-button" id="kmeans-centroids">2. Random centroids</button>
              <button class="btn btn-outline-primary step-button" id="kmeans-assign">3. Assign points</button>
              <button class="btn btn-outline-primary step-button" id="kmeans-move">4. Move centroids</button>
              <button class="btn btn-outline-secondary step-button" id="kmeans-next">Next iteration</button>
              <button class="btn btn-success step-button" id="kmeans-animate">▶ Start animation</button>
              <button class="btn btn-outline-danger step-button" id="kmeans-reset">Reset</button>
            </div>
          </div>

          <!-- Step Indicator -->
          <div class="step-indicator">
            <div class="step-dot" id="step-0"></div>
            <div class="step-dot" id="step-1"></div>
            <div class="step-dot" id="step-2"></div>
            <div class="step-dot" id="step-3"></div>
          </div>

          <!-- Step Description -->
          <div class="step-description" id="kmeans-description">
            <h6>K-means algorithm:</h6>
            <p class="mb-0">K-means is an iterative algorithm that partitions data into k clusters. Click on the steps above for step-by-step visualization.</p>
          </div>

          <!-- Visualization -->
          <div class="text-center">
            <img id="kmeans-image" class="viz-image" style="display: none;">
          </div>
        </div>
      </div>

      <!-- DBSCAN Panel -->
      <div class="tab-pane fade" id="dbscan-panel" role="tabpanel">
        <div class="viz-container">
          <h3 class="viz-title">DBSCAN Clustering</h3>
          
          <!-- Parameter Controls -->
          <div class="parameter-controls">
            <div class="row">
              <div class="col-md-3">
                <label for="eps-value" class="form-label">Epsilon (ε):</label>
                <input type="number" class="form-control" id="eps-value" value="0.5" min="0.1" max="2.0" step="0.1">
              </div>
              <div class="col-md-3">
                <label for="min-samples-value" class="form-label">Min. samples:</label>
                <input type="number" class="form-control" id="min-samples-value" value="5" min="2" max="20">
              </div>
              <div class="col-md-3">
                <label for="dbscan-samples" class="form-label">Number of points:</label>
                <input type="number" class="form-control" id="dbscan-samples" value="100" min="50" max="500" step="50">
              </div>
              <div class="col-md-3">
                <label class="form-label">Current ε:</label>
                <div class="form-control-plaintext" id="eps-display">0.5</div>
              </div>
            </div>
          </div>

          <!-- Step Controls -->
          <div class="step-controls">
            <h5>Algorithm steps:</h5>
            <div class="d-flex flex-wrap">
              <button class="btn btn-primary step-button" id="dbscan-data">1. Show data</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-circles">2. Epsilon circles</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-neighbors">3. Neighbor points</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-core">4. Core points</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-border">5. Border points</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-noise">6. Noise points</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-clusters">7. Clusters</button>
              <button class="btn btn-outline-primary step-button" id="dbscan-final">8. Final result</button>
              <button class="btn btn-success step-button" id="dbscan-animate">▶ Start animation</button>
              <button class="btn btn-outline-secondary step-button" id="dbscan-run">Run DBSCAN</button>
              <button class="btn btn-outline-danger step-button" id="dbscan-reset">Reset</button>
            </div>
          </div>

          <!-- Step Indicator -->
          <div class="step-indicator">
            <div class="step-dot" id="dbscan-step-0"></div>
            <div class="step-dot" id="dbscan-step-1"></div>
            <div class="step-dot" id="dbscan-step-2"></div>
            <div class="step-dot" id="dbscan-step-3"></div>
            <div class="step-dot" id="dbscan-step-4"></div>
            <div class="step-dot" id="dbscan-step-5"></div>
            <div class="step-dot" id="dbscan-step-6"></div>
            <div class="step-dot" id="dbscan-step-7"></div>
          </div>

          <!-- Step Description -->
          <div class="step-description" id="dbscan-description">
            <h6>DBSCAN algorithm:</h6>
            <p class="mb-0">DBSCAN is a density-based algorithm that finds clusters of various shapes and identifies noise. Adjust the parameters ε and min_samples for different results.</p>
          </div>

          <!-- Visualization -->
          <div class="text-center">
            <img id="dbscan-image" class="viz-image" style="display: none;">
          </div>
        </div>
      </div>
    </div>

    <!-- Loading -->
    <div id="loading" class="loading">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <p class="mt-2">Generating visualization...</p>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // Global state
    let currentAlgorithm = 'kmeans';
    let kmeansStep = 0;
    let kmeansIteration = 0;
    let dbscanStep = 0;
    let isAnimating = false;

    // K-means event listeners
    document.getElementById('kmeans-init').addEventListener('click', () => {
      kmeansStep = 0;
      updateKmeansStep();
    });

    document.getElementById('kmeans-centroids').addEventListener('click', () => {
      kmeansStep = 1;
      updateKmeansStep();
    });

    document.getElementById('kmeans-assign').addEventListener('click', () => {
      kmeansStep = 2;
      updateKmeansStep();
    });

    document.getElementById('kmeans-move').addEventListener('click', () => {
      kmeansStep = 3;
      updateKmeansStep();
    });

    document.getElementById('kmeans-next').addEventListener('click', () => {
      kmeansIteration++;
      document.getElementById('k-iteration').value = kmeansIteration;
      updateKmeansStep();
    });

    document.getElementById('kmeans-animate').addEventListener('click', () => {
      animateKmeans();
    });

    document.getElementById('kmeans-reset').addEventListener('click', () => {
      // Reset server state first
      fetch('/api/kmeans_reset', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        }
      })
      .then(() => {
        // Stop any running animation
        isAnimating = false;
        const animateButton = document.getElementById('kmeans-animate');
        animateButton.disabled = false;
        animateButton.innerHTML = '▶ Start animation';
        
        // Reset client state
        kmeansStep = 0;
        kmeansIteration = 0;
        document.getElementById('k-iteration').value = 0;
        updateKmeansStep();
        updateStepIndicators('kmeans', 0);
      })
      .catch(error => {
        console.error('Error resetting:', error);
        // Stop any running animation
        isAnimating = false;
        const animateButton = document.getElementById('kmeans-animate');
        animateButton.disabled = false;
        animateButton.innerHTML = '▶ Start animation';
        
        // Still reset client state even if server reset fails
        kmeansStep = 0;
        kmeansIteration = 0;
        document.getElementById('k-iteration').value = 0;
        updateKmeansStep();
        updateStepIndicators('kmeans', 0);
      });
    });

    // DBSCAN event listeners
    document.getElementById('dbscan-data').addEventListener('click', () => {
      dbscanStep = 0;
      updateDbscanStep();
    });

    document.getElementById('dbscan-circles').addEventListener('click', () => {
      dbscanStep = 1;
      updateDbscanStep();
    });

    document.getElementById('dbscan-neighbors').addEventListener('click', () => {
      dbscanStep = 2;
      updateDbscanStep();
    });

    document.getElementById('dbscan-core').addEventListener('click', () => {
      dbscanStep = 3;
      updateDbscanStep();
    });

    document.getElementById('dbscan-border').addEventListener('click', () => {
      dbscanStep = 4;
      updateDbscanStep();
    });

    document.getElementById('dbscan-noise').addEventListener('click', () => {
      dbscanStep = 5;
      updateDbscanStep();
    });

    document.getElementById('dbscan-clusters').addEventListener('click', () => {
      dbscanStep = 6;
      updateDbscanStep();
    });

    document.getElementById('dbscan-final').addEventListener('click', () => {
      dbscanStep = 7;
      updateDbscanStep();
    });

    document.getElementById('dbscan-run').addEventListener('click', () => {
      dbscanStep = 7;
      updateDbscanStep();
    });

    document.getElementById('dbscan-animate').addEventListener('click', () => {
      animateDbscan();
    });

    document.getElementById('dbscan-reset').addEventListener('click', () => {
      // Reset server state first
      fetch('/api/dbscan_reset', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        }
      })
      .then(() => {
        // Reset client state
        dbscanStep = 0;
        updateDbscanStep();
        updateStepIndicators('dbscan', 0);
      })
      .catch(error => {
        console.error('Error resetting:', error);
        // Still reset client state even if server reset fails
        dbscanStep = 0;
        updateDbscanStep();
        updateStepIndicators('dbscan', 0);
      });
    });

    // Parameter change listeners
    document.getElementById('eps-value').addEventListener('input', (e) => {
      document.getElementById('eps-display').textContent = e.target.value;
      if (dbscanStep >= 1) {
        updateDbscanStep();
      }
    });

    document.getElementById('min-samples-value').addEventListener('input', () => {
      if (dbscanStep >= 2) {
        updateDbscanStep();
      }
    });

    document.getElementById('k-clusters').addEventListener('input', () => {
      if (kmeansStep >= 1) {
        updateKmeansStep();
      }
    });

    document.getElementById('k-samples').addEventListener('input', () => {
      if (kmeansStep >= 0) {
        updateKmeansStep();
      }
    });

    document.getElementById('dbscan-samples').addEventListener('input', () => {
      if (dbscanStep >= 0) {
        updateDbscanStep();
      }
    });

    // Tab change listener
    document.querySelectorAll('[data-bs-toggle="tab"]').forEach(tab => {
      tab.addEventListener('shown.bs.tab', (e) => {
        if (e.target.id === 'kmeans-tab') {
          currentAlgorithm = 'kmeans';
        } else if (e.target.id === 'dbscan-tab') {
          currentAlgorithm = 'dbscan';
        }
      });
    });

    function updateKmeansStep() {
      showLoading();
      
      const k = parseInt(document.getElementById('k-clusters').value);
      const n_samples = parseInt(document.getElementById('k-samples').value);
      
      fetch('/api/kmeans_step', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          step: kmeansStep,
          iteration: kmeansIteration,
          k: k,
          n_samples: n_samples
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();
        if (data.image) {
          document.getElementById('kmeans-image').src = `data:image/png;base64,${data.image}`;
          document.getElementById('kmeans-image').style.display = 'block';
        }
        
        // Update iteration counter from server response
        if (data.iteration !== undefined) {
          kmeansIteration = data.iteration;
          document.getElementById('k-iteration').value = kmeansIteration;
        }
        
        // Check for convergence
        if (data.converged && isAnimating) {
          isAnimating = false;
          const animateButton = document.getElementById('kmeans-animate');
          animateButton.disabled = false;
          animateButton.innerHTML = '▶ Start animation';
          updateStepIndicators('kmeans', 3);
        }
        
        updateKmeansDescription();
        updateStepIndicators('kmeans', kmeansStep);
      })
      .catch(error => {
        hideLoading();
        console.error('Error:', error);
        alert('Error generating visualization');
      });
    }

    function updateDbscanStep() {
      showLoading();
      
      const eps = parseFloat(document.getElementById('eps-value').value);
      const min_samples = parseInt(document.getElementById('min-samples-value').value);
      const n_samples = parseInt(document.getElementById('dbscan-samples').value);
      
      fetch('/api/dbscan_step', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          step: dbscanStep,
          eps: eps,
          min_samples: min_samples,
          n_samples: n_samples
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();
        if (data.image) {
          document.getElementById('dbscan-image').src = `data:image/png;base64,${data.image}`;
          document.getElementById('dbscan-image').style.display = 'block';
        }
        updateDbscanDescription();
        updateStepIndicators('dbscan', dbscanStep);
      })
      .catch(error => {
        hideLoading();
        console.error('Error:', error);
        alert('Error generating visualization');
      });
    }

    function updateKmeansDescription() {
      const descriptions = [
        {
          title: "Step 1: Show data",
          text: "We display the initial data - points in 2D space that we want to partition into clusters."
        },
        {
          title: "Step 2: Random centroids",
          text: "K-means starts with randomly placed centroids (cluster centers). The number of centroids corresponds to the number of desired clusters."
        },
        {
          title: "Step 3: Assign points",
          text: "Each point is assigned to the nearest centroid. Distances are shown as lines. Points of the same color belong to the same cluster."
        },
        {
          title: "Step 4: Move centroids",
          text: "Centroids are moved to the center (mean) of their assigned points. Arrows show the direction of movement. This process repeats until centroids stabilize."
        }
      ];

      const desc = descriptions[kmeansStep] || descriptions[0];
      document.getElementById('kmeans-description').innerHTML = `
        <h6>${desc.title}</h6>
        <p class="mb-0">${desc.text}</p>
      `;
    }

    function updateDbscanDescription() {
      const descriptions = [
        {
          title: "Step 1: Show data",
          text: "We display the initial data - points in 2D space. DBSCAN can find clusters of various shapes and identify noise."
        },
        {
          title: "Step 2: Epsilon circles",
          text: `For each point, an epsilon circle (ε = ${document.getElementById('eps-value').value}) is displayed. Points inside the circle are considered neighbors.`
        },
        {
          title: "Step 3: Neighbor points",
          text: `Red lines show connections between points that are less than ε = ${document.getElementById('eps-value').value} apart. These points are considered neighbors.`
        },
        {
          title: "Step 4: Core points",
          text: `Core points (red circles) are points that have at least ${document.getElementById('min-samples-value').value} neighbors in the epsilon circle. These points form the core of clusters.`
        },
        {
          title: "Step 5: Border points",
          text: `Border points (blue squares) are points that have fewer than ${document.getElementById('min-samples-value').value} neighbors but are neighbors of some core point. They belong to clusters but don't form their core.`
        },
        {
          title: "Step 6: Noise points",
          text: `Noise points (black X) are points that are neither core nor border points. They are isolated or in very sparse areas and don't belong to any cluster.`
        },
        {
          title: "Step 7: Forming clusters",
          text: `Clusters are formed by connecting core points that are mutually reachable. Border points are added to the nearest core points. Noise points remain unassigned.`
        },
        {
          title: "Step 8: Final result",
          text: `Final result of the DBSCAN algorithm with parameters ε = ${document.getElementById('eps-value').value} and min_samples = ${document.getElementById('min-samples-value').value}. Shows clusters in different colors and noise points.`
        }
      ];

      const desc = descriptions[dbscanStep] || descriptions[0];
      document.getElementById('dbscan-description').innerHTML = `
        <h6>${desc.title}</h6>
        <p class="mb-0">${desc.text}</p>
      `;
    }

    function updateStepIndicators(algorithm, currentStep) {
      const prefix = algorithm === 'kmeans' ? '' : 'dbscan-';
      const maxSteps = algorithm === 'kmeans' ? 4 : 8;
      
      for (let i = 0; i < maxSteps; i++) {
        const dot = document.getElementById(`${prefix}step-${i}`);
        dot.classList.remove('active', 'completed');
        
        if (i < currentStep) {
          dot.classList.add('completed');
        } else if (i === currentStep) {
          dot.classList.add('active');
        }
      }
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    // Animation functions
    function animateKmeans() {
      const animateButton = document.getElementById('kmeans-animate');
      animateButton.disabled = true;
      animateButton.innerHTML = '⏸ Animation running...';
      isAnimating = true;
      
      // Reset to start
      kmeansStep = 0;
      kmeansIteration = 0;
      document.getElementById('k-iteration').value = 0;
      
      // First show data
      updateKmeansStep();
      
      setTimeout(() => {
        // Show centroids
        kmeansStep = 1;
        updateKmeansStep();
        
        setTimeout(() => {
          // Start iterations
          animateKmeansIterations();
        }, 500);
      }, 500);
    }
    
    function animateKmeansIterations() {
      // Stop if animation was cancelled (e.g., due to convergence)
      if (!isAnimating) {
        return;
      }
      
      // Assign points
      kmeansStep = 2;
      updateKmeansStep();
      
      setTimeout(() => {
        // Stop if animation was cancelled
        if (!isAnimating) {
          return;
        }
        
        // Move centroids
        kmeansStep = 3;
        updateKmeansStep();
        
        setTimeout(() => {
          // Stop if animation was cancelled
          if (!isAnimating) {
            return;
          }
          
          // Check if we should continue or stop
          if (kmeansIteration >= 15) {
            // Animation complete - reached max iterations
            isAnimating = false;
            const animateButton = document.getElementById('kmeans-animate');
            animateButton.disabled = false;
            animateButton.innerHTML = '▶ Start animation';
            updateStepIndicators('kmeans', 3);
          } else {
            // Continue animation - next iteration
            kmeansIteration++;
            document.getElementById('k-iteration').value = kmeansIteration;
            animateKmeansIterations();
          }
        }, 500);
      }, 500);
    }
    
    function animateDbscan() {
      const animateButton = document.getElementById('dbscan-animate');
      animateButton.disabled = true;
      animateButton.innerHTML = '⏸ Animation running...';
      
      // Reset to start
      dbscanStep = 0;
      
      // Animate through all steps
      const steps = [0, 1, 2, 3, 4, 5, 6, 7];
      let currentStepIndex = 0;
      
      function nextStep() {
        if (currentStepIndex < steps.length) {
          dbscanStep = steps[currentStepIndex];
          updateDbscanStep();
          updateStepIndicators('dbscan', dbscanStep);
          currentStepIndex++;
          
          setTimeout(nextStep, 500);
        } else {
          // Animation complete
          animateButton.disabled = false;
          animateButton.innerHTML = '▶ Spustit animaci';
        }
      }
      
      nextStep();
    }

    // Initialize
    updateKmeansStep();
    updateDbscanStep();
  </script>
</body>
</html>
